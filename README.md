
# Building (Compiling And Running Executables)
- This project uses the `meson` build system along with `ninja`. In short, `meson` is comparable to `cmake`, it helps you configure your build. And `ninja` is comparable to `make`, which helps you actually build your binaries. `Ninja` uses the file called `compile_commands.json` in the build directory generated by `meson` to find out how to build your binaries. You can find more information on `meson` here: https://mesonbuild.com/
- To initialize the build setup using meson run: `meson build` in the terminal.
- A folder with the name "build" has now appeared in your project (but no executables have been built yet)
- To compile all the executables type: `ninja -C build` (`-C build` means we're first going into the `build` directory before running any of the ninja commands)
- To compile a single executable after build setup, type: `ninja -C build` followed by the path of the executable. For instance, to compile main in bst folder, type `ninja -C build test/bst/main.cpp.executable`
- All the executables are under `./build/test/`. For instance, to run the main executable in bst folder, type: `./build/test/bst/main.cpp.executable`
- (Take a look at the `meson.build` files in the project root, src and test directories to understand how the build process works.)

# Testing
There are 2 ways of running the unit tests (files with `test_` prefix in test folder):
- `meson test -C build`
- `ninja -C build test`

Both of these commands have their own special use cases:
- Running a test under GDB
  - `meson test -C build --gdb 'the name of my test'`
- Running all the tests under valgrind
  - `meson test -C build --wrapper=valgrind`

Other than unit tests, there are also testing executables compiled using your code (like main.cpp.executable).
- Compiling a single testing executable
  - `ninja -C build test/path/file-name.cpp.executable`

If you have already compiled testing executable, you can run it like so: `./build/test/path/file-name.cpp.executable`

## GoogleTest
The GoogleTest framework allows you write atomic tests for your code without calling that test in a main or fitting it into your existing set of tests. In this assignment, each file in src folder has a corrsponding test file in the test folder with prefix `test_`. To write a test, use the `TEST` macro:
```cpp
TEST(SuiteName, TestName) {
    // Test code goes here
}
```

The GoogleTest framework uses assertions to determine whether a test has passed or failed. For instance, here are some of the assertions available:

- `ASSERT_EQ(val1, val2)` - Fails the test if the two values are not the same (note: this uses the `==` operator, so for pointers, it looks for pointer equality instead of equality between the two underlying objects).
- `ASSERT_NE(val1, val2)` - Fails the test if the two values are the same.
- `ASSERT_GT(val1, val2)` - Fails the test if `val1 <= val2`.
- `ASSERT_GE(val1, val2)` - Fails the test if `val1 < val2`
- `ASSERT_LT(val1, val2)` - Fails the test if `val1 >= val2`
- `ASSERT_LE(val1, val2)` - Fails the test if `val1 > val2`

You can learn more about writing tests from the [GoogleTest documentation](https://github.com/google/googletest/blob/master/googletest/docs/primer.md).

*Optional:* If you want to add a new C++ file with tests, you will also have to update the corresponding `meson.build` file. As you can see below, for `test_BST.cpp` we have to first define an executable, and then define a test that runs this executable.

```python
test_bst_exe = executable('test_BST.cpp.executable', 
    sources: ['test_BST.cpp'], 
    dependencies : [bst, gtest_dep, util])
test('my BST test', test_bst_exe)
```

## Code Coverage
Calculating code coverage is a way of measuring the quality of your test suite. 
A code coverage report shows the lines of code that were executed by your tests. 
This will give you insight into the weaknesses in your test suite as you can easily see which lines of code are not yet tested.

You can generate a code coverage report of your tests by running:
`ninja -C build cov`
The coverage report should appear under `build/meson-logs/coveragereport`. You can open `index.html` in your browser to see the full report.

If you are ssh'd into ieng6, you will need to download the coverage report to your computer first before you can open it in a browser.

# Tools for Code Quality
This project includes numerous tools that can help you make sure that the quality of your code is on par. 

## Auto Formatting
If you're working in a devcontainer, you may already have noticed that the code gets autoformatted when you save. This project is using `clang-format` to achieve that.
On ieng6, you'll have to run `clang-format` yourself.

To run `clang-format` on the entire project run:
`ninja -C build clang-format`

## Static Analysis
Static analysis tools parse your source code for possible causes of bugs and violations of code style rules.
They will notify you of suspicious looking code that may have a bug in it.

This project supports the following 3 static analyzers:
- `ninja -C build cppcheck`
- `ninja -C build clang-tidy`
- `ninja -C build scan-build`

## Dynamic Analysis
Dynamic analysis tools do not parse the source code, but execute the compiled files. This project supports `Valgrind`.
- `meson test -C build --wrapper=valgrind`
- `valgrind build/test/bst/test_BST.cpp.executable`

# Debugging
Both the devcontainer and ieng6 come with gdb installed and by default all source files are compiled with debugging support enabled. 

You can run gdb like this: `gdb build/test/bst/test_BST.cpp.executable`

Try debugging main and then try debugging a test.

## Debugging in the devcontainer
In the devcontainer we've also included 2 debugging tasks in the VSCode setup.
Click the debug window icon on the left or use the short cut ctrl+shift+d (cmd+shift+d on mac).
You can see the following debug tasks:
![Debug](images/debug.png "Debug")

You can run the debug task by clicking the green play icon. 

Alternatively, you can press F5 to run the currently selected debug task.

⚠️NOTE: In case of an error when running a debug task the first thing to try is usually to delete your build dir and generate it again using `meson build` and `ninja -C build`.
⚠️NOTE: The "debug active file" task will not work if your active file does not have a meson configuration to be compiled to an executable. In case of an error look at the corresponding `build.meson` to make sure that the file you are trying to debug is being compiled into an executable. 

You can create breakpoints by clicking left of the line numbers in VSCode.
